using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO.Ports;
using System.Threading;

namespace WindowsFormsApplication1
{
    public partial class Form1 : Form
    {
        Thread threadsender, threadreciver;

        bool threaddoing = false;
        byte[] commands = new byte[14];
        byte[] requestor = { 0x02, 0x46, 0x31, 0x03 };
        Button[] buttons = new Button[32];

        const byte STX = 0x02, CMD1 = 0x46, CMD2 = 0x30, ETX = 0x03;
        int[] iDATA = { 0, 0, 0, 0, 0, 0, 0, 0 }, iCRC = { 0, 0 }, outdata = { 1, 2, 4, 8 };
        byte[] DATA = { 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 }, CRC = { 0x30, 0x30 };

        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            //연결된 포트 이름들 배열 저장
            string[] ports = SerialPort.GetPortNames();

            //저장된 배열값을 콤보박스에 저장 및 자동으로 첫번째 할당
            ComboBoxPort.Items.AddRange(ports);
            if (ComboBoxPort.Items.Count > 0)
            {
                ComboBoxPort.SelectedIndex = 0;
            }
            CommandSetter();

            //In Out 콤보박스 기본 out 모드
            ComboBoxInOut.SelectedIndex = 1;

            //각 신호를 담당할 버튼을 목록 변수화
            buttons = new Button[]
            { bt1, bt2, bt3, bt4, bt5, bt6, bt7, bt8, bt9, bt10,
                bt11, bt12, bt13, bt14, bt15, bt16, bt17, bt18, bt19, bt20,
                bt21, bt22, bt23, bt24, bt25, bt26, bt27, bt28, bt29, bt30,
                bt31, bt32
            };
        }

        private void ButtonConnect_Click(object sender, EventArgs e)
        {
            if (!Port1.IsOpen)
            {
                //콤보박스로 설정된 포트와 레이트로 연결, 그 외의 값은 고정값으로 지정
                Port1.PortName = ComboBoxPort.SelectedItem.ToString();
                Port1.BaudRate = 115200;
                Port1.DataBits = 8;
                Port1.StopBits = StopBits.One;
                Port1.Parity = Parity.None;
                //이전 명령어와 다음 명령어 텀 설정
                Port1.WriteTimeout = 10;
                Port1.ReadTimeout = 10;
                //값을 받기 위한 구문
                Port1.DataReceived += new SerialDataReceivedEventHandler(Port1_DataReceived);

                //위에서 설정한 값으로 포트 오픈
                Port1.Open();

                //통신 동안 설정 값이 바뀌지 않게 고정
                ComboBoxPort.Enabled = false;
                ComboBoxInOut.Enabled = false;

                //버튼 표시 변경
                btConnect.Text = "Disconnect";
                btConnect.BackColor = Color.PaleGreen;

                if (ComboBoxInOut.SelectedItem.ToString() == "Input")
                {
                    //상태 수신 쓰레드 시작
                    CommandReciver();
                }
                else if (ComboBoxInOut.SelectedItem.ToString() == "Output")
                {
                    //명령어 송신 쓰레드 시작
                    CommandSender();
                }
            }
            else
            {
                //쓰레드 탈출을 위한 bool 값 제어
                threaddoing = false;

                //다시 설정 변경할 수 있도록 사용 가능으로 변경
                ComboBoxPort.Enabled = true;
                ComboBoxInOut.Enabled = true;

                //버튼 표시 변경
                btConnect.Text = "Connect";
                btConnect.BackColor = Color.Gainsboro;

                //통신 종료
                Port1.Close();
            }
        }

        private void Port1_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            //쓰레드 충돌 방지
            this.Invoke(new EventHandler(PortReciver));
        }

        private void PortReciver(object s, EventArgs e)
        {
            //수신 값의 길이
            int bytelength = Port1.BytesToRead;
            //수신 값을 저장할 배열을 길이 만큼 생성
            byte[] data = new byte[bytelength];
            //data 배열에 수신된 값 저장
            Port1.Read(data, 0, bytelength);

            //받은 신호의 길이 12로 규격에 맞는 값을 받을경우 해석
            if (data.Length == 12)
            {
                //받은 값 중에서 신호를 송출하는 구간만 해석하는 함수로 전달
                ButtonSelector(System.Text.Encoding.UTF8.GetString(data).Substring(1, 8));
            }
        }

        private void ButtonSelector(string data)
        {
            for (int i = 0; i < data.Length; i++)
            {
                //순서가 온 값을 정수로 변경
                int num = int.Parse(data[i].ToString(), System.Globalization.NumberStyles.HexNumber);
                //제일 뒤가 1번 부터기때문에 순서 역순으로 계산
                int time = data.Length - i - 1;
                //마지막에 한번에 버튼 색상을 변경하기 위해서 배치, 기본 값은 Moccasin
                Color[] backcolor = new Color[] { Color.Moccasin, Color.Moccasin, Color.Moccasin, Color.Moccasin };

                //첫번째 신호가 1이기때문에 홀수일 경우 무조껀 첫번째에서 제외가능
                if (num % 2 == 1)
                {
                    num--;
                    backcolor[0] = Color.PaleGreen;
                }
                else
                {
                    //그 외의 신호의 경우 큰값부터 차례로 제거하면서 색상 변경
                    while (num > 0)
                    {
                        if (num >= 8)
                        {
                            num -= 8;
                            backcolor[3] = Color.PaleGreen;
                        }
                        if (num >= 4)
                        {
                            num -= 4;
                            backcolor[2] = Color.PaleGreen;
                        }
                        if (num >= 2)
                        {
                            num -= 2;
                            backcolor[1] = Color.PaleGreen;
                        }
                    }
                }

                //신호에 맞게 적용된 색상 표기
                buttons[(4 * time) + 0].BackColor = backcolor[0];
                buttons[(4 * time) + 1].BackColor = backcolor[1];
                buttons[(4 * time) + 2].BackColor = backcolor[2];
                buttons[(4 * time) + 3].BackColor = backcolor[3];
            }
        }

        private void CommandSender()
        {
            threadsender = new Thread(ThreadSender);
            threadsender.IsBackground = true;
            //쓰레드 반복을 위한 bool 값 제어
            threaddoing = true;

            threadsender.Start();
        }

        private void CommandReciver()
        {
            threadreciver = new Thread(ThreadReciver);
            threadreciver.IsBackground = true;
            //쓰레드 반복을 위한 bool 값 제어
            threaddoing = true;

            threadreciver.Start();
        }

        private void ThreadSender()
        {
            while (threaddoing)
            {
                //저장된 신호 commands 배열 송신
                Port1.Write(commands, 0, commands.Length);

                //다음 송신까지 텀
                Thread.Sleep(150);
            }
            //threaddoing이 false 이 될 경우 탈출해서 쓰레드 종료
            threadsender.Abort();
        }

        private void ThreadReciver()
        {
            while (threaddoing)
            {
                //저장된 신호 commands 배열 송신
                Port1.Write(requestor, 0, requestor.Length);

                //다음 송신까지 텀
                Thread.Sleep(150);
            }
            //threaddoing이 false 이 될 경우 탈출해서 쓰레드 종료
            //threadsender.Abort();
        }

        private void BtOutput_Click(object sender, EventArgs e)
        {
            //누른 버튼을 인식해 몇 번째 버튼인지 확인
            Button bt = (Button)sender;
            int target = Array.IndexOf(buttons, bt);

            //버튼의 배경색을 인식해 on off 조절
            if (bt.BackColor == Color.Moccasin)
            {
                iDATA[target / 4] += outdata[target % 4];
                bt.BackColor = Color.PaleGreen;
            }
            else
            {
                iDATA[target / 4] -= outdata[target % 4];
                bt.BackColor = Color.Moccasin;
            }

            //위 코드로 인해 바뀐 iDATA 값을 명령어에 적용
            CommandSetter();
        }

        private void CommandSetter()
        {
            //iDATA에 저장된 현제 on off 된 데이터값을 byte로 변환해서 DATA에 저장
            for (int i = 0; i < iDATA.Length; i++)
            {
                DATA[i] = Convert.ToByte(iDATA[i].ToString("X")[0]);
            }

            commands[0] = STX;
            commands[1] = CMD1;
            commands[2] = CMD2;

            commands[3] = DATA[7];
            commands[4] = DATA[6];
            commands[5] = DATA[5];
            commands[6] = DATA[4];
            commands[7] = DATA[3];
            commands[8] = DATA[2];
            commands[9] = DATA[1];
            commands[10] = DATA[0];

            CRCSetter();
            commands[11] = CRC[1];
            commands[12] = CRC[0];

            commands[13] = ETX;
        }

        private void CRCSetter()
        {
            //CRC 값은 각 DATA 그룹의 MSB, LSB 값을 더하여 위치, LSB의 값이 16이 넘어 다음 단위로 갈 경우 MSB 에 합산
            iCRC[0] = iDATA[0] + iDATA[2] + iDATA[4] + iDATA[6];
            int up = iCRC[0] / 16;
            iCRC[0] %= 16;

            iCRC[1] = iDATA[1] + iDATA[3] + iDATA[5] + iDATA[7] + up;
            iCRC[1] %= 16;

            CRC[1] = Convert.ToByte(iCRC[1].ToString("X")[0]);
            CRC[0] = Convert.ToByte(iCRC[0].ToString("X")[0]);
        }

        private void BtOutputALL_Click(object sender, EventArgs e)
        {
            //버튼 이름을 미리 지정해 on off 인식하여 iDATA 값을 전부 15, 0 으로 조절하여 작동
            //개별 작동시 버튼 색을 인식하여 on off 하기 때문에 배경 색도 조절
            if ((Button)sender == btALLON)
            {
                foreach (Button bt in buttons)
                {
                    bt.BackColor = Color.PaleGreen;
                }

                for (int i = 0; i < iDATA.Length; i++)
                {
                    iDATA[i] = 15;
                }
            }
            else if ((Button)sender == btALLOFF)
            {
                foreach (Button bt in buttons)
                {
                    bt.BackColor = Color.Moccasin;
                }

                for (int i = 0; i < iDATA.Length; i++)
                {
                    iDATA[i] = 0;
                }
            }

            //위에서 수정된 iDATA 값을 이용해 CRC 값 입력
            CRCSetter();
            CommandSetter();
        }

        private void ComboBoxInOut_SelectedIndexChanged(object sender, EventArgs e)
        {
            ComboBox cb = (ComboBox)sender;

            Button[] bts = new Button[]
                { bt1, bt2, bt3, bt4, bt5, bt6, bt7, bt8, bt9, bt10,
                    bt11, bt12, bt13, bt14, bt15, bt16, bt17, bt18, bt19, bt20,
                    bt21, bt22, bt23, bt24, bt25, bt26, bt27, bt28, bt29, bt30,
                    bt31, bt32
                };

            //콤보박스 inout 에 따라 모드 변경
            if (cb.SelectedItem.ToString() == "Output")
            {
                tb0116.Text = "Output 1 - 16";
                tb1732.Text = "Output 17 - 32";

                foreach (Button bt in bts)
                {
                    bt.Click += BtOutput_Click;
                }

                btALLON.Click += BtOutputALL_Click;
                btALLOFF.Click += BtOutputALL_Click;
            }
            else if (cb.SelectedItem.ToString() == "Input")
            {
                tb0116.Text = "Intput 1 - 16";
                tb1732.Text = "Intput 17 - 32";

                foreach (Button bt in bts)
                {
                    bt.Click -= BtOutput_Click;
                }

                btALLON.Click -= BtOutputALL_Click;
                btALLOFF.Click -= BtOutputALL_Click;
            }
        }
    }
}
